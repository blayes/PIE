dd <- 1; rr <- 1
alphas <- deltas[dd]^seq(1, nfactor, by = 1)# * log(nobs)
etas <- rep(rhos[rr], nfactor)# / sqrt(nobs)

alphas
etas
res <- sampleXfa(ymat, lambdaMat, sigma2, alphas, etas, 1, 1, 10000, 5000, 5)
res <- sampleXfa(ymat, lambdaMat, sig2, alphas, etas, 1, 1, 10000, 5000, 5)
sig2
lambdaMat
ymat <- sims$data
res <- sampleXfa(ymat, lambdaMat, sig2, alphas, etas, 1, 1, 10000, 5000, 5)
covMat
zMat
zmat
plot(zmat)
plot(zmat)
plot(zmat[,1], zmat[,2])
cov(zmat[,1], zmat[,2])
c
zetaMat
c
c
c
mus
c
tauMat
c
lambdaMat
resids
head(resids)
colSums(resids^2)
    shp <- nobs / 2 + 1
    for (ii in 1:ndim) {
      sigma2[ii] <- rinvgamma(1, shape = shp, scale = scl[ii])
    }

c
sigma2
c
c
c
c
c
c
c
c
c
c
c
c
c
sigma2
lambdaMat
    shpAa <- 0.5
    sclAa <- nuErr / sigma2 + 1 / ascl0^2

sclAa
Q
loads <- matrix(c(0.95, 0.90, 0.85, rep(0, 3), 0, 0, 0, 0.80, 0.75, 0.70), nrow = 6, ncol = 2)
loads
sig2 <- c(rep(0.95, 250), rep(0.90, 250), rep(0.85, 250), rep(0.80, 250))
sig2
sig2 <- diag(diag(1, 6) - tcrossprod(loads))
sig2
idenLam <- svd(sYY, nu = nfactor, nv = nfactor)
lambdaMat <- idenLam$u[ , 1:nfactor] * matrix(idenLam$d[1:nfactor], nrow = ndim, ncol = nfactor, byrow = TRUE) *
  matrix(sign(idenLam$u[1, 1:nfactor]), ndim, nfactor, byrow = TRUE)

lambdaMat
res <- sampleXfa(ymat, lambdaMat, sig2, alphas, etas, 1, 1, 10000, 5000, 5)
Q
res <- sampleXfa(ymat, lambdaMat, sig2, alphas, etas, 1, 1, 10000, 5000, 5)
res$lambdaMatSamp
head(res$sigmaSamp)
boxplot(res$sigmaSamp)
sig2
res <- sampleXfa(ymat, lambdaMat, sig2, alphas, etas, 10000, 5000, 5)
boxplot(res$sigmaSamp)
res <- sampleXfa(ymat, lambdaMat, sig2, alphas, etas, 1, 1, 10000, 5000, 5)
boxplot(res$sigmaSamp)
res$lambdaMatSampp[1, 1, ]
res$lambdaMatSamp[1, 1, ]
plot(res$lambdaMatSamp[1, 1, ])
plot(res$lambdaMatSamp[2, 1, ])
plot(res$lambdaMatSamp[3, 1, ])
plot(res$lambdaMatSamp[4, 1, ])
plot(res$lambdaMatSamp[5, 1, ])
plot(res$lambdaMatSamp[6, 1, ])
plot(res$lambdaMatSamp[1, 2, ])
plot(res$lambdaMatSamp[2, 2, ])
plot(res$lambdaMatSamp[3, 2, ])
plot(res$lambdaMatSamp[4, 2, ])
plot(res$lambdaMatSamp[5, 2, ])
plot(res$lambdaMatSamp[6, 2, ])
par(mfrow = c(2,6)); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 1,])
par(mfrow = c(2,6)); for (ii in 1:6) hist(res$lambdaMatSamp[ii,
  1,]); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 2,])
lambdaMat
fit <- factanal(ymat, 3, rotation="varimax")
fit$loadings[,1:2]
names(fit)
(fit$uniquenesses)
res <- sampleXfa(ymat, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, 1, 1, 10000, 5000, 5)
par(mfrow = c(2,6)); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 1,]); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 2,])
res <- sampleXfa(ymat, fit$loadings[,1:nfactor], (fit$uniquenesses), rep(2, 1), rep(1, 1), 1, 1, 10000, 5000, 5)
res <- sampleXfa(ymat, fit$loadings[,1:nfactor], (fit$uniquenesses), rep(2, 2), rep(1, 2), 1, 1, 10000, 5000, 5)
par(mfrow = c(2,6)); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 1,]); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 2,])
est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)
est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)
est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, 100, 1e-10)
est
 fit$loadings[,1:nfactor]
svd( fit$loadings[,1:nfactor])
princomp(ymat)
?princomp
tmp <- princomp(ymat)
tmp$loadings
fit <- factanal(t(ymat), 2, rotation="varimax")
fit <- factanal(sYY, 2, covmat = TRUE, n.obs = 1000, rotation="varimax")
ymat
ndim <- 6
nfactor <- 2
nobs <- 200

loads <- matrix(c(0.95, 0.90, 0.85, rep(0, 3), 0, 0, 0, 0.80, 0.75, 0.70), nrow = 6, ncol = 2)
sig2 <- diag(diag(1, 6) - tcrossprod(loads))

sims <- simulateData(nobs, loads, sig2)
sims
dim(t(ymat))
fit <- factanal(t(ymat), 2, rotation="varimax")
fit <- factanal(ymat, 2, rotation="varimax")
fit
res <- sampleXfa(ymat, fit$loadings[ , 1:nfactor], fit$uniquenesses, alphas, etas, 1, 1, 10000, 5000, 5)
par(mfrow = c(2,6)); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 1,]); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 2,])
est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)
maxiter <- 100; tol <- 1e-10
est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)

est
alphas
etas
est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)
est
(fit$uniquenesses)
alphas
maxiter <- 100; tol <- 1e-10; deltas   <- seq(2, 5, by = 0.1); rhos <- 10^seq(-1, 0.5, length = 5)
alphas <- deltas[1]^seq(1, nfactor, by = 1) * log(nobs)
etas <- rep(rhos[1], nfactor) / sqrt(nobs)

est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)

alphas
est
maxiter <- 100; tol <- 1e-10; deltas   <- seq(4, 5, by = 0.1); rhos <- 10^seq(-1, 0.5, length = 5)
alphas <- deltas[1]^seq(1, nfactor, by = 1) * log(nobs)
etas <- rep(rhos[1], nfactor) / sqrt(nobs)

est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)

est
maxiter <- 100; tol <- 1e-10; deltas   <- seq(5, 10, by = 0.1); rhos <- 10^seq(-1, 0.5, length = 5)
alphas <- deltas[1]^seq(1, nfactor, by = 1) * log(nobs)
etas <- rep(rhos[1], nfactor) / sqrt(nobs)

alphas
est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)
est
maxiter <- 100; tol <- 1e-10; deltas   <- seq(8, 10, by = 0.1); rhos <- 10^seq(-1, 0.5, length = 5)
alphas <- deltas[1]^seq(1, nfactor, by = 1) * log(nobs)
etas <- rep(rhos[1], nfactor) / sqrt(nobs)

est <- updateLoadingsUniquenessMat(sYY, fit$loadings[,1:nfactor], (fit$uniquenesses), alphas, etas, nobs, maxiter, tol)
est
res <- sampleXfa(ymat, fit$loadings[ , 1:nfactor], fit$uniquenesses, alphas, etas, 1, 1, 10000, 5000, 5)
par(mfrow = c(2,6)); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 1,]); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 2,])
par(mfrow = c(2,6)); for (ii in 1:6) plot(res$lambdaMatSamp[ii, 1,],
  type = 'l'); for (ii in 1:6) plot(res$lambdaMatSamp[ii, 2,], type = 'l')
res <- sampleXfa(ymat, fit$loadings[ , 1:nfactor], fit$uniquenesses, rep(1, 2), rep(1, 2), 1, 1, 10000, 5000, 5)
par(mfrow = c(2,6)); for (ii in 1:6) plot(res$lambdaMatSamp[ii, 1,],
  type = 'l'); for (ii in 1:6) plot(res$lambdaMatSamp[ii, 2,], type = 'l')
res$sigmaSamp
boxplot(res$sigmaSamp)
sig2
est <- updateLoadingsUniquenessMat(sYY, loads, sig2, rep(2, 2),
  rep(1, 1), nobs, maxiter, tol)
est
est <- updateLoadingsUniquenessMat(sYY, loads, sig2, alphas, etas, nobs, maxiter, tol)
est
loads
nobs
ndim
  agrid <- seq(0.01, 0.99, length = 100)
    logWtAlpha <- ndim * log((1 - agrid) / agrid) - colSums(log(1 + abs(lambdaMat))) / agrid
ndim <- 6
    logWtAlpha <- ndim * log((1 - agrid) / agrid) - colSums(log(1 + abs(lambdaMat))) / agrid
    logWtAlpha <- ndim * log((1 - agrid) / agrid) - colSums(log(1 + abs(loads))) / agrid
    logWtAlpha <- ndim * log((1 - agrid) / agrid) - colSums(log(1 + abs(load))) / agrid
rm(list=ls())
sims
dim(sims$data)
lambdaMat <- fit$loadings[,1:2]
sigma2 <- fit$uniquenesses
sigma2
    logWtAlpha <- ndim * log((1 - agrid) / agrid) - colSums(log(1 + abs(lambdaMat))) / agrid
logWtAlpha
max(logWtAlpha)
exp(logWtAlpha - max(logWtAlpha))
exp(logWtAlpha - max(logWtAlpha)) / sum(exp(logWtAlpha - max(logWtAlpha)))
plot(exp(logWtAlpha - max(logWtAlpha)) / sum(exp(logWtAlpha - max(logWtAlpha))))
(exp(logWtAlpha - max(logWtAlpha)) / sum(exp(logWtAlpha - max(logWtAlpha))))
sum(exp(logWtAlpha - max(logWtAlpha)) / sum(exp(logWtAlpha - max(logWtAlpha))))
plot.default(exp(logWtAlpha - max(logWtAlpha)) / sum(exp(logWtAlpha - max(logWtAlpha))))
colSums(log(1 + abs(lambdaMat)))
ndim * log((1 - agrid) / agrid)
    logWtAlpha <- matrix(0, length(agrid), nfactor)
logWtAlpha
ndim * log((1 - agrid) / agrid)
ndim * log((1 - agrid) / agrid) - colSums(log(1 + abs(lambdaMat[ , kk]))) / agrid
kk <- 1
ndim * log((1 - agrid) / agrid) - colSums(log(1 + abs(lambdaMat[ , kk]))) / agrid
lambdaMat
kk
ndim * log((1 - agrid) / agrid) - sum(log(1 + abs(lambdaMat[ , kk]))) / agrid
logWtAlpha
colMaxs(logWtAlpha)
matrix(colMaxs(logWtAlpha), ndim, nfactor, byrow = TRUE)
logWtAlpha - matrix(colMaxs(logWtAlpha), ndim, nfactor, byrow = TRUE)
logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE)
 logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE)
boxplo( logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE))
boxplot( logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE))
exp(logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE))
sample(seq_along(agrid), probs = probsAlpha)
sample(seq_along(agrid), prob = probsAlpha)
    probsAlpha <- exp(logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE))
sample(seq_along(agrid), prob = probsAlpha[,kk])
exp(logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE))
idx <- sample(seq_along(agrid), 1, probs = probsAlpha[ , kk])
idx <- sample(seq_along(agrid), 1, prob = probsAlpha[ , kk])
idx
    for (kk in 1:nfactor) {
      idx <- sample(seq_along(agrid), 1, prob = probsAlpha[ , kk])
      alphas[kk] <- 1 / agrid[idx] - 1
    }

alphas
res <- sampleXfa(ymat, fit$loadings[ , 1:nfactor], fit$uniquenesses, rep(1, 2), rep(1, 2), 1, 1, 10000, 5000, 5)
par(mfrow = c(2,10)); for (ii in 31:50) plot(density(res$lambdaMatSamp[ii, 2,]))
par(mfrow = c(2,6)); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 1,]); for (ii in 1:6) hist(res$lambdaMatSamp[ii, 2,])
res <- sampleXfa(ymat, fit$loadings[ , 1:nfactor], fit$uniquenesses, rep(1, 2), rep(1, 2), 1, 1, 10000, 5000, 5)
res <- sampleXfa(ymat, fit$loadings[ , 1:nfactor], fit$uniquenesses, rep(1, 2), rep(1, 2), 1, 1, 10000, 5000, 5)
res$alphaSamp
plot(res$alphaSamp[,1])
plot(res$alphaSamp[,1], type = 'l')
plot(res$alphaSamp[,2], type = 'l')
plot(res$alphaSamp[,2], type = 'l')
ymat) / sigma2
ymat / sigma2
rm(list=ls())
lmat0 <- matrix(c(rep(5, ndim), rep(5, ndim / 2), rep(-5, ndim / 2)), ncol = nfactor, nrow = ndim)
sig20 <- rep(0.1, ndim)

lmat0
sig20
dim(lmat0)
dim(sig20)
length(sig20)
lmat0
lmat0 %*% rnorm(nfactor)
rnorm(1, sd = sqrt(sig20))
rnorm(ndim, sd = sqrt(sig20))
sig20 <- rep(0.1, ndim) * seq(1, ndim, by = 1) / 10
sig20
sig20 <- rep(0.1, ndim) * seq(1, ndim, by = 1) 
sig20
sqrt(sig20)
ndim <- 8
nfactor <- 2
nobs <- 100

lmat0 <- matrix(c(rep(5, ndim), rep(5, ndim / 2), rep(-5, ndim / 2)), ncol = nfactor, nrow = ndim)
sig20 <- rep(0.1, ndim) * seq(1, ndim, by = 1)

dat0 <- matrix(0.0, nobs, ndim)
for (ii in 1:nobs) {
  dat0[ii, ] <- lmat0 %*% rnorm(nfactor)
  for (jj in 1:ndim) {
    dat0[ii, jj] <- dat0[ii, jj] + rnorm(1, sd = sqrt(sig20[jj]))
  }
}

dat0
dim(dat0)
dat0
dim(dat0)
(dat0)
boxplot(dat0)
matrix(colMeans(dat0), nobs, ndim, byrow = TRUE)
centdat0 <- (dat0 - matrix(colMeans(dat0), nobs, ndim, byrow = TRUE))
centdat0
centdat0 <- (dat0 - matrix(colMeans(dat0), nobs, ndim, byrow = TRUE))
syy0 <- crossprod(centdat0)/ nobs

syy0
idenLam <- svd(sYY, nu = nfactor, nv = nfactor)
idenLam <- svd(syy0, nu = nfactor, nv = nfactor)
idenLam
idenLam1
fit <- factanal(dat0, 2, rotation="varimax")
fit
lmat0
sig20
sigma2 <- sig20
sigma2
nfactor
ndim
nobs
  nfactor <- ncol(lambdaMat)
  ndim <- nrow(lambdaMat)
  nobs <- nrow(ymat)

  cts <- 0
  zmatSamp <- array(0.0, dim = c(nobs, nfactor, (niter - nburn) / nthin))
  sigmaSamp <- matrix(0.0, (niter - nburn) / nthin, ndim)
  alphaSamp <- matrix(0.0, (niter - nburn) / nthin, nfactor)
  lambdaMatSamp <- array(0.0, dim = c(ndim, nfactor, (niter - nburn) / nthin))

  etas <- rep(1, nfactor)
  agrid <- seq(0.01, 0.99, length = 100)
  zetaMat <- matrix(0.0, ndim, nfactor)
  tauMat <- matrix(0.0, ndim, nfactor)

nburn <- 5000
niter <- 10000
nthin <- 5
  nuErr <- 2; aErr <- rep(1, ndim); aA <- 10^4
nuErr
aErr
aA
ymat) / sigma2
ymat / sigma2
dim(ymat)
length( sigma2)
fit
lmat0
sig20
dim(ymat)
ymat / sigma2
dim(ymat)
length(sigma2)
ymat / sigma2
dim(t(ymat))
sig20
ymat
ymat / sigma2
 sigma2
dim((t(ymat) / sigma2))
dim(tcrossprod(covMat, lambdaMat))
    muMat <- tcrossprod(covMat, lambdaMat) %*% (t(ymat) / sigma2)
crossprod(chol(covMat), matrix(rnorm(nfactor * nobs), nfactor, nobs))
muMat
    zmat <- t(crossprod(chol(covMat), matrix(rnorm(nfactor * nobs), nfactor, nobs))) + t(muMat)
zmat
boxplot(zmat)
    for (ii in 1:ndim) {
      for (jj in 1:nfactor) {
        zetaMat[ii, jj] <- rgamma(1, shape = alphas[jj] + 1, scale = etas[jj] + abs(lambdaMat[ii, jj]))
      }
    }

    mus <- abs(zetaMat / lambdaMat)
    lams <- zetaMat^2
    for (ii in 1:ndim) {
      for (jj in 1:nfactor) {
        tauMat[ii, jj] <- 1 / rig(1, mean = mus[ii, jj], scale = 1 / lams[ii, jj])
      }
    }

alphas <- rep(1, nfactor)
etas <- rep(1, nfactor)
    for (ii in 1:ndim) {
      for (jj in 1:nfactor) {
        zetaMat[ii, jj] <- rgamma(1, shape = alphas[jj] + 1, scale = etas[jj] + abs(lambdaMat[ii, jj]))
      }
    }

    mus <- abs(zetaMat / lambdaMat)
    lams <- zetaMat^2
    for (ii in 1:ndim) {
      for (jj in 1:nfactor) {
        tauMat[ii, jj] <- 1 / rig(1, mean = mus[ii, jj], scale = 1 / lams[ii, jj])
      }
    }

tauMat
zetaMat
    mus <- abs(zetaMat / lambdaMat)
    lams <- zetaMat^2
    for (ii in 1:ndim) {
      for (jj in 1:nfactor) {
        tauMat[ii, jj] <- 1 / rig(1, mean = mus[ii, jj], scale = 1 / lams[ii, jj])
      }
    }

tauMat
    for (ii in 1:ndim) {
      for (jj in 1:nfactor) {
        zetaMat[ii, jj] <- rgamma(1, shape = alphas[jj] + 1, scale = etas[jj] + abs(lambdaMat[ii, jj]))
      }
    }

    mus <- abs(zetaMat / lambdaMat)
    lams <- zetaMat^2
    for (ii in 1:ndim) {
      for (jj in 1:nfactor) {
        tauMat[ii, jj] <- 1 / rig(1, mean = mus[ii, jj], scale = 1 / lams[ii, jj])
      }
    }

    covMat <- chol2inv(chol(crossprod(lambdaMat, lambdaMat / sigma2) + diag(1, nfactor)))
    muMat <- tcrossprod(covMat, lambdaMat) %*% (t(ymat) / sigma2)
    zmat <- t(crossprod(chol(covMat), matrix(rnorm(nfactor * nobs), nfactor, nobs))) + t(muMat)

covMat
muMat
zmat
plot(zmat)
gramMat / sigma2[ii]
    gramMat <- crossprod(zmat, zmat)
gramMat
gramMat / sigma2[ii]
gramMat
tauMat[ii, ]
(gramMat / sigma2[ii] + diag(1 / tauMat[ii, ]))
chol(gramMat / sigma2[ii] + diag(1 / tauMat[ii, ]))
      covLam <- chol2inv(chol(gramMat / sigma2[ii] + diag(1 / tauMat[ii, ])))
covLam
      muLam <- covLam %*% crossprod(zmat, ymat[ , ii]) / sigma2[ii]
as.numeric(muLam + crossprod(chol(covLam), rnorm(nfactor)))
    gramMat <- crossprod(zmat, zmat)
    for (ii in 1:ndim) {
      covLam <- chol2inv(chol(gramMat / sigma2[ii] + diag(1 / tauMat[ii, ])))
      muLam <- covLam %*% crossprod(zmat, ymat[ , ii]) / sigma2[ii]
      lambdaMat[ii, ] <- as.numeric(muLam + crossprod(chol(covLam), rnorm(nfactor)))
    }

ymat - tcrossprod(zmat, lambdaMat)
dim(tcrossprod(zmat, lambdaMat) )
ymat
ymat
dim(ymat)
dim(tcrossprod(zmat, lambdaMat))
zmat
zmat
t(lambdaMat)
    resids <- ymat - tcrossprod(zmat, lambdaMat)
resids
dim(resids)
    resids <- ymat - tcrossprod(zmat, lambdaMat)
    scl <- colSums(resids^2) / 2 + aa
    shp <- nobs / 2 + bb
    for (ii in 1:ndim) {
      sigma2[ii] <- rinvgamma(1, shape = shp, scale = scl[ii])
    }

aa <- 1
bb <- 1
    resids <- ymat - tcrossprod(zmat, lambdaMat)
    scl <- colSums(resids^2) / 2 + aa
    shp <- nobs / 2 + bb
    for (ii in 1:ndim) {
      sigma2[ii] <- rinvgamma(1, shape = shp, scale = scl[ii])
    }

sigma2
resids
scl
sigma2
    idenLam <- svd(lambdaMat, nu = nfactor, nv = nfactor)
    lambdaMat <- idenLam$u[ , 1:nfactor] * matrix(idenLam$d[1:nfactor], nrow = ndim, ncol = nfactor, byrow = TRUE) * matrix(sign(idenLam$u[1, 1:nfactor]), nrow = ndim, ncol = nfactor, byrow = TRUE)

lambdaMat
ndim * log((1 - agrid) / agrid)
ndim * log((1 - agrid) / agrid) - sum(log(1 + abs(lambdaMat[ , jj]) / etas[jj])) / agrid
exp(logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE))
    logWtAlpha <- matrix(0, length(agrid), nfactor)
    for (jj in 1:nfactor) {
      logWtAlpha[ , jj] <- ndim * log((1 - agrid) / agrid) - sum(log(1 + abs(lambdaMat[ , jj]) / etas[jj])) / agrid
    }

logWtAlpha
exp(logWtAlpha)
sample(seq_along(agrid), 1, prob = probsAlpha[ , jj])
    probsAlpha <- exp(logWtAlpha - matrix(colMaxs(logWtAlpha), length(agrid), nfactor, byrow = TRUE))
sample(seq_along(agrid), 1, prob = probsAlpha[ , jj])
fit$loadings
as.matrix(fit$loadings)
str(fit$loadings)
fit$loadings[ l:2]
fit$loadings[ ,1:2]
sig0
sigs0
sig20
runif(ndim)
res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)
res$sigmaSamp
boxplot(res$sigmaSamp)
plot(res$sigmaSamp[,1], type = 'l')
plot(res$sigmaSamp[,3], type = 'l')
plot(res$sigmaSamp[,5], type = 'l')
plot(res$sigmaSamp[,10], type = 'l')
plot(res$sigmaSamp[,8], type = 'l')
abline(h=0.8)
plot(res$sigmaSamp[,7], type = 'l')
par(mfrow = c(2,4)); for (ii in 1:8) plot(res$sigmaSamp[, ii], type
  = 'l')
par(mfrow = c(2,4)); for (ii in 1:8) {plot(res$sigmaSamp[, ii], type
  = 'l'); abline(h=ii/10, col = 'red')}
ndim <- 8
nfactor <- 2
nobs <- 100

lmat0 <- matrix(c(rep(5, ndim), rep(5, ndim / 2), rep(-5, ndim / 2)), ncol = nfactor, nrow = ndim)
sig20 <- seq(1, ndim, by = 1) / 10

dat0 <- matrix(0.0, nobs, ndim)
for (ii in 1:nobs) {
  dat0[ii, ] <- lmat0 %*% rnorm(nfactor)
  for (jj in 1:ndim) {
    dat0[ii, jj] <- dat0[ii, jj] + rnorm(1, sd = sqrt(sig20[jj]))
  }
}

lambdaMat <- lmat0
sigma2 <- sig20
ymat <- dat0

fit <- factanal(ymat, 2, rotation="varimax")

res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)

par(mfrow = c(2,4)); for (ii in 1:8) {plot(res$sigmaSamp[, ii], type
  = 'l'); abline(h=ii/10, col = 'red')}
par(mfrow = c(2,4)); for (ii in 1:8) {plot(res$sigmaSamp[, ii], type = 'l'); abline(h=ii/10, col = 'red')}
    resids <- ymat - tcrossprod(zmat, lambdaMat)
dim(ymat)
par(mfrow = c(2,4)); for (ii in 1:8) {plot(res$sigmaSamp[, ii], type = 'l'); abline(h=ii/10, col = 'red')}
par(mfrow = c(2,4)); for (ii in 1:8) {plot(res$lambdaMatSamp[ii, 1, ], type = 'l')}
par(mfrow = c(2,4)); for (ii in 1:8) {plot(res$lambdaMatSamp[ii, 2, ], type = 'l')}
ndim <- 50
nfactor <- 5
nobs <- 1000

lmat0 <- matrix(c(rep(5, ndim), rep(5, ndim / 2), rep(-5, ndim / 2)), ncol = nfactor, nrow = ndim)
sig20 <- seq(1, ndim, by = 1) / 10

dat0 <- matrix(0.0, nobs, ndim)
for (ii in 1:nobs) {
  dat0[ii, ] <- lmat0 %*% rnorm(nfactor)
  for (jj in 1:ndim) {
    dat0[ii, jj] <- dat0[ii, jj] + rnorm(1, sd = sqrt(sig20[jj]))
  }
}

lambdaMat <- lmat0
sigma2 <- sig20
ymat <- dat0

fit <- factanal(ymat, 2, rotation="varimax")

res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)

alphaSamp
ndim <- 50
nfactor <- 2
nobs <- 1000

lmat0 <- matrix(c(rep(5, ndim), rep(5, ndim / 2), rep(-5, ndim / 2)), ncol = nfactor, nrow = ndim)
sig20 <- seq(1, ndim, by = 1) / 10

dat0 <- matrix(0.0, nobs, ndim)
for (ii in 1:nobs) {
  dat0[ii, ] <- lmat0 %*% rnorm(nfactor)
  for (jj in 1:ndim) {
    dat0[ii, jj] <- dat0[ii, jj] + rnorm(1, sd = sqrt(sig20[jj]))
  }
}

lambdaMat <- lmat0
sigma2 <- sig20
ymat <- dat0

fit <- factanal(ymat, 2, rotation="varimax")

res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)

par(mfrow = c(2,4)); for (ii in 1:8) {plot(res$lambdaMatSamp[ii, 2, ], type = 'l')}
par(mfrow = c(2,4)); for (ii in 1:2) {boxplot(t(res$lambdaMatSamp[, ii, ]))}
res$sigmaSamp
boxplot(res$sigmaSamp)
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$sigmaSamp[, ii], type = 'l'); abline(h=ii/10, col = 'red')}
house <- function (vec) {
  nelem <- length(vec)
  essPart <- vec[2:nelem]
  lenSqEssPart <- sum(essPart * essPart)
  vv <- c(1, essPart)

  if (lenSqEssPart == 0) {
    bet <- 0
  } else {
    mu <- sqrt(vec[1]^2 + lenSqEssPart)
    if (vec[1] <= 0) {
      vv[1] <- vec[1] - mu
    } else {
      vv[1] <- - lenSqEssPart / (mu + vec[1])
    }
    bet <- 2 * vv[1]^2 / (lenSqEssPart + vv[1]^2)
    vv <- vv / vv[1]
  }

  list(beta = bet,
       v = vv
       )
}

##' Lower triangulation using Household QRs based on Section 5.2 Householder QRs in Golub & VanLoan (2012).
##'
##' Transform a matrix of P by K dimensions to a lower triangular matrix with positive diagonals.
##' @title Lower Triangulation
##' @param mat matrix to be lower triangularized
##' @param tol entries below tol are 0
##' @return Lower triangular matrix with positive diagonals
##' @author Sanvesh Srivastava
##' @examples
##' amat <- matrix(runif(50), 10, 5)
##' rmat <- lowerTriangularize(amat)
lowerTriangularize <- function (mat, tol = 1e-15) {
  nc <- ncol(mat)
  nr <- nrow(mat)
  for (ii in 1:(nc - 1)) {
    houseComp <- house(mat[ii, ii:nc])
    vv <- c(rep(0, length = ii - 1), houseComp$v)
    cat("vv: ", vv, "\n")
    mat <- mat - tcrossprod(houseComp$beta * (mat %*% vv), vv)
    idx <- which(mat[ii, ] < tol)
    mat[ii, idx] <- 0
    cat("mat: ", "\n")
    print(mat)
  }
  idx <- which(diag(mat) < 0)
  ## this ensures the identifiability of loadings matrix is maintained
  mat[ , idx] <- -mat[ , idx]
  mat
}

house <- function (vec) {
  nelem <- length(vec)
  essPart <- vec[2:nelem]
  lenSqEssPart <- sum(essPart * essPart)
  vv <- c(1, essPart)

  if (lenSqEssPart == 0) {
    bet <- 0
  } else {
    mu <- sqrt(vec[1]^2 + lenSqEssPart)
    if (vec[1] <= 0) {
      vv[1] <- vec[1] - mu
    } else {
      vv[1] <- - lenSqEssPart / (mu + vec[1])
    }
    bet <- 2 * vv[1]^2 / (lenSqEssPart + vv[1]^2)
    vv <- vv / vv[1]
  }

  list(beta = bet,
       v = vv
       )
}

##' Lower triangulation using Household QRs based on Section 5.2 Householder QRs in Golub & VanLoan (2012).
##'
##' Transform a matrix of P by K dimensions to a lower triangular matrix with positive diagonals.
##' @title Lower Triangulation
##' @param mat matrix to be lower triangularized
##' @param tol entries below tol are 0
##' @return Lower triangular matrix with positive diagonals
##' @author Sanvesh Srivastava
##' @examples
##' amat <- matrix(runif(50), 10, 5)
##' rmat <- lowerTriangularize(amat)
lowerTriangularize <- function (mat, tol = 1e-15) {
  nc <- ncol(mat)
  nr <- nrow(mat)
  for (ii in 1:(nc - 1)) {
    houseComp <- house(mat[ii, ii:nc])
    vv <- c(rep(0, length = ii - 1), houseComp$v)
    mat <- mat - tcrossprod(houseComp$beta * (mat %*% vv), vv)
    idx <- which(mat[ii, ] < tol)
    mat[ii, idx] <- 0
  }
  idx <- which(diag(mat) < 0)
  ## this ensures the identifiability of loadings matrix is maintained
  mat[ , idx] <- -mat[ , idx]
  mat
}

lowerTriangularize(lambdaMat)
fit$loadings
res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)
crossprod(lambdaMat, lambdaMat / sigma2)
lambdaMat
lambdaMat[abs(lambdaMat) < tol] <- 0
lambdaMat[abs(lambdaMat) < 1r-15] <- 0
lambdaMat[abs(lambdaMat) < 1e-15] <- 0
lambdaMat
fit$loadings
res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)
gramMat
chol(gramMat / sigma2[ii] + diag(1 / tauMat[ii, ]))
diag(1 / tauMat[ii, ])
zetaMat
tauMat
    for (jj in 1:nfactor) {
      for (ii in jj:ndim) {
          zetaMat[ii, jj] <- rgamma(1, shape = alphas[jj] + 1, scale = etas[jj] + abs(lambdaMat[ii, jj]))
          tauMat[ii, jj] <- 1 / rig(1, mean = abs(zetaMat[ii, jj] / lambdaMat[ii, jj]), scale = 1 / zetaMat[ii, jj]^2)
      }
    }

zetaMat
tauMat
lambdaMatNew
lambdaMat
fit
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$sigmaSamp[, ii], type = 'l'); abline(h=ii/10, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$lambdaMatSamp[ii,
  1, ], type = 'l'); abline(h=ii/10, col = 'red')}
dim(lambdaMat)
dim(res$lambdaMatSamp)
res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)
dim(res$lambdaMatSamp)
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$lambdaMatSamp[ii,
  1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$lambdaMatSamp[ii, 2, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
(res$alphaSamp)
head(res$alphaSamp)
plot(res$alphaSamp[,1], type = 'l')
plot(res$alphaSamp[,2], type = 'l')
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$zmatSamp[ii, 2, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$zmatSamp[1, 2, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
dim(res$zmatSamp)
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$zmatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 20000, 10000, 10)
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$zmatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$lambdaMatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {hist(res$lambdaMatSamp[ii, 1, ])}
trilam <- res$lambdaMatSamp
dim(trilam)
for (ii in 1:1000) trilam[ , , ii] =
  lowerTriangularize(res$lambdaMatSamp[ , , ii])
trilam[, , 1]
diag(trilam[, , 1])
diag(trilam[, , 2])
diag(trilam[, , 3])
par(mfrow = c(5,10)); for (ii in 1:50) {plot(trilam[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(trilam[ii, 2, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
plot(res$alphaSamp[,1])
plot(res$alphaSamp[,2])
  nuErr <- 2; aErr <- rep(1, ndim); aA <- 10^2
  nu <- 2; aFac <- rep(1, nfactor)

    ## prior for the random effects covariance matrix
    sclAFac <- nu * diag(factCov) + 1 / aA^2
    shpAFac <- 0.5 * (nu + 1)
    for (ss in 1:nfactor) {
      aFac[ss] <- rinvgamma(1, shape = shpAFac, scale = sclAFac[ss])
    }

factCov <- diag(1, nfactor)
    sclAFac <- nu * diag(factCov) + 1 / aA^2
    shpAFac <- 0.5 * (nu + 1)
    for (ss in 1:nfactor) {
      aFac[ss] <- rinvgamma(1, shape = shpAFac, scale = sclAFac[ss])
    }

aFac
    factCovScl <- crossprod(zmat, zmat) + 2 * nu * diag(1 / aFac)
factCovScl
    factCovDf <- nu + nfactor + nobs - 1
factCovDf
    factCovInf <- rWishart(1, factCovDf, solve(factCovScl))[ , , 1]
factCovInf
    factCovMat <- solve(factCovInf)
factCovMat
    covMat <- chol2inv(chol(crossprod(lambdaMat, lambdaMat / sigma2) + factCovInf))
    muMat <- tcrossprod(covMat, lambdaMat) %*% (t(ymat) / sigma2)
    zmat <- t(crossprod(chol(covMat), matrix(rnorm(nfactor * nobs), nfactor, nobs))) + t(muMat)

zmat
res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)
res$lambdaMatSamp
par(mfrow = c(5,10)); for (ii in 1:50) {hist(res$lambdaMatSamp[ii, 1, ])}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$lambdaMatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$zmatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
res <- sampleXfa(ymat, fit$loadings + 10, runif(ndim), rep(1, nfactor), rep(1, nfactor), 1, 1, 10000, 5000, 5)
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$zmatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$lambdaMatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
dim(zsamp)
dim(res$zmatSamp)
res$zmatSamp[1, , 1]
dim(res$lambdaMatSamp)
dim(res$lambdaMatSamp[ , , ii])
res$lambdaMatSamp[ , , ii] %*% cc
  cc <- solve(chol(factCovSamp[ , , ii]))
  cc <- solve(chol(res$factCovSamp[ , , ii]))
cc
factCovSamp[,,1]
res$factCovSamp[,,1]
res$factCovSamp[,,2]
res$factCovSamp[,,3]
res$factCovSamp[,,3]
par(mfrow = c(5,10)); for (ii in 1:50) {plot(lsamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(zsamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(zsamp[ii, 1, -(1:500)], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
zsamp <- res$zmatSamp
lsamp <- res$lambdaMatSamp
for (ii in 1:1000) {
  cc <- solve(chol(res$factCovSamp[ , , ii]))
  lsamp[ , , ii] <- res$lambdaMatSamp[ , , ii] %*% cc
    idenLam <- svd(lsamp[,,ii], nu = nfactor, nv = nfactor)
    lsamp[ , , ii] <- idenLam$u[ , 1:nfactor] * matrix(idenLam$d[1:nfactor], nrow = ndim, ncol = nfactor, byrow = TRUE) * matrix(sign(idenLam$u[1, 1:nfactor]), nrow = ndim, ncol = nfactor, byrow = TRUE)

  for (nn in 1:nobs) {
    zsamp[nn, , ii] <- crossprod(cc, res$zmatSamp[nn, , ii])
  }
}

par(mfrow = c(5,10)); for (ii in 1:50) {plot(zsamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(zsamp[ii, 1, -(1:500)], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(lsamp[ii, 1, -(1:500)], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$lambdaMatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(res$zmatSamp[ii, 1, ], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(zsamp[ii, 1, -(1:500)], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(lsamp[ii, 1, -(1:500)], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
zsamp <- res$zmatSamp
lsamp <- res$lambdaMatSamp
for (ii in 1:1000) {
  cc <- solve(chol(res$factCovSamp[ , , ii]))
  lsamp[ , , ii] <- res$lambdaMatSamp[ , , ii] %*% t(chol(res$factCovSamp[ , , ii]))
    idenLam <- svd(lsamp[,,ii], nu = nfactor, nv = nfactor)
    lsamp[ , , ii] <- idenLam$u[ , 1:nfactor] * matrix(idenLam$d[1:nfactor], nrow = ndim, ncol = nfactor, byrow = TRUE) * matrix(sign(idenLam$u[1, 1:nfactor]), nrow = ndim, ncol = nfactor, byrow = TRUE)
  for (nn in 1:nobs) {
    zsamp[nn, , ii] <- crossprod(cc, res$zmatSamp[nn, , ii])
  }
}


par(mfrow = c(5,10)); for (ii in 1:50) {plot(lsamp[ii, 1, -(1:500)], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {plot(lsamp[ii, 2, -(1:500)], type = 'l'); abline(h=3, col = 'red'); abline(h=-3, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {hist(lsamp[ii, 2, -(1:500)]); abline(v=5, col = 'red'); abline(h=-5, col = 'red')}
par(mfrow = c(5,10)); for (ii in 1:50) {hist(lsamp[ii, 1, -(1:500)]); abline(v=5, col = 'red'); abline(h=-5, col = 'red')}
res$alphaSamp
plot(res$alphaSamp[,1], type = 'l')
plot(res$alphaSamp[,2], type = 'l')
hist(res$alphaSamp[,1])
hist(res$alphaSamp[,2])
if (0) {print("no")} else {stop("ff")}
